document.addEventListener('DOMContentLoaded', function() {
    // Elements
    const canvas = document.getElementById('editor-canvas');
    const dropMessage = document.getElementById('drop-message');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    const exportBtn = document.getElementById('export-btn');
    const addTextBtn = document.getElementById('add-text-btn');
    const uploadImage = document.getElementById('upload-image');
    const templatesContainer = document.getElementById('templates-container');
    
    // New elements
    const resetBtn = document.getElementById('reset-btn');
    const autoSizeBtn = document.getElementById('auto-size-btn');
    const aspectRatio = document.getElementById('aspect-ratio');
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    
    // Text controls
    const textControls = document.getElementById('text-controls');
    const textInput = document.getElementById('text-input');
    const textSize = document.getElementById('text-size');
    const textSizeValue = document.getElementById('text-size-value');
    const textColor = document.getElementById('text-color');
    const positionTop = document.getElementById('position-top');
    const positionBottom = document.getElementById('position-bottom');
    const deleteTextBtn = document.getElementById('delete-text-btn');
    
    // Image controls
    const imageControls = document.getElementById('image-controls');
    const imageScale = document.getElementById('image-scale');
    const imageScaleValue = document.getElementById('image-scale-value');
    const deleteImageBtn = document.getElementById('delete-image-btn');
    const bringFrontBtn = document.getElementById('bring-front-btn');
    const sendBackBtn = document.getElementById('send-back-btn');
    
    // State
    let images = [];
    let texts = [];
    let historyStates = [];
    let currentHistoryIndex = -1;
    let isDragging = false;
    let isResizing = false;
    let resizeDirection = '';
    let selectedImageIndex = -1;
    let selectedTextIndex = -1;
    let dragStartX, dragStartY;
    let initialX, initialY;
    let initialWidth, initialHeight;
    let currentAspectRatio = { width: 1, height: 1 }; // Default to square
    let isDarkMode = true;
    let isCollisionEnabled = true; // Default to collision detection enabled
    
    // Add touch event support for better mobile experience
    let initialTouchDistance = 0;
    let initialScale = 1;
    
    // Default template images - add your own template URLs here
    const templates = [
        { src: 'https://i.imgflip.com/1bij.jpg', name: 'One Does Not Simply' },
        { src: 'https://i.imgflip.com/1g8my4.jpg', name: 'Two Buttons' },
        { src: 'https://i.imgflip.com/1bgw.jpg', name: 'Distracted Boyfriend' },
        { src: 'https://i.imgflip.com/1bh8.jpg', name: 'Batman Slapping Robin' },
        { src: 'https://i.imgflip.com/1ihzfe.jpg', name: 'Expanding Brain' },
        { src: 'https://i.imgflip.com/1h7in3.jpg', name: 'Who Would Win?' },
        { src: 'https://i.imgflip.com/9ehk.jpg', name: 'Black Girl Wat' }
    ];
    
    // Initialize
    initializeTemplates();
    
    // Initialize with default aspect ratio (1:1)
    updateCanvasAspectRatio('1:1');
    
    // Ensure the canvas is sized correctly on page load
    updateCanvasSize();
    
    // Add click handler for collision toggle
    const collisionStatus = document.getElementById('collision-status');
    if (collisionStatus) {
        collisionStatus.addEventListener('click', toggleCollision);
        collisionStatus.style.cursor = 'pointer';
        // Initialize collision status display
        updateCollisionStatus();
    }
    
    // Event listeners
    canvas.addEventListener('dragover', handleDragOver);
    canvas.addEventListener('drop', handleDrop);
    canvas.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    // Add window resize event listener with debounce
    let resizeTimeout;
    window.addEventListener('resize', function() {
        // Clear the timeout if it exists
        if (resizeTimeout) {
            clearTimeout(resizeTimeout);
        }
        
        // Set a new timeout
        resizeTimeout = setTimeout(function() {
            updateCanvasSize();
            
            // If there are images or texts on the canvas, rearrange them to fit the new size
            if (images.length > 0 || texts.length > 0) {
                arrangeImagesOptimally();
            }
        }, 200); // 200ms debounce
    });
    
    // Add orientation change handler for mobile devices
    window.addEventListener('orientationchange', function() {
        // Show loading indicator during orientation change
        showLoading("Adjusting layout...");
        
        // Need a longer delay for orientation changes as they take time to complete
        setTimeout(function() {
            updateCanvasSize();
            
            if (images.length > 0 || texts.length > 0) {
                arrangeImagesOptimally();
            }
            
            hideLoading();
        }, 500);
    });
    
    // Add touch event support for better mobile experience
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd);
    
    // New button event listeners
    resetBtn.addEventListener('click', resetCanvas);
    autoSizeBtn.addEventListener('click', arrangeImagesOptimally);
    
    // Fix aspect ratio toggles
    const aspectRatioToggles = document.querySelectorAll('.aspect-toggle');
    aspectRatioToggles.forEach(toggle => {
        toggle.addEventListener('click', function() {
            // Remove active class from all toggles
            aspectRatioToggles.forEach(t => t.classList.remove('active'));
            // Add active class to clicked toggle
            this.classList.add('active');
            // Update aspect ratio
            updateCanvasAspectRatio(this.dataset.ratio);
        });
    });
    
    darkModeToggle.addEventListener('click', toggleDarkMode);
    
    // Add keyboard event listener for delete keys
    document.addEventListener('keydown', function(e) {
        // Delete or Backspace key when an image or text is selected
        if ((e.key === 'Delete' || e.key === 'Backspace') && 
            (document.activeElement === document.body || document.activeElement === canvas)) {
            if (selectedImageIndex !== -1) {
                deleteSelectedImage();
                e.preventDefault(); // Prevent browser back navigation on backspace
            } else if (selectedTextIndex !== -1) {
                deleteSelectedText();
                e.preventDefault();
            }
        }
    });
    
    // Text controls
    textSize.addEventListener('input', updateTextSize);
    textSizeValue.textContent = `${textSize.value}px`;
    textInput.addEventListener('input', updateSelectedText);
    textColor.addEventListener('input', updateTextColor);
    
    positionTop.addEventListener('click', () => positionText('top'));
    positionBottom.addEventListener('click', () => positionText('bottom'));
    deleteTextBtn.addEventListener('click', deleteSelectedText);
    
    addTextBtn.addEventListener('click', addNewText);
    
    // Image controls
    imageScale.addEventListener('input', updateImageScale);
    deleteImageBtn.addEventListener('click', deleteSelectedImage);
    bringFrontBtn.addEventListener('click', bringSelectedImageToFront);
    sendBackBtn.addEventListener('click', sendSelectedImageToBack);
    
    // File upload
    uploadImage.addEventListener('change', handleFileUpload);
    
    // Action listeners
    undoBtn.addEventListener('click', handleUndo);
    redoBtn.addEventListener('click', handleRedo);
    exportBtn.addEventListener('click', exportAsPNG);
    
    // Initialize template grid
    function initializeTemplates() {
        templates.forEach((template, index) => {
            const templateItem = document.createElement('div');
            templateItem.className = 'template-item';
            templateItem.title = template.name;
            
            const img = document.createElement('img');
            img.src = template.src;
            img.alt = template.name;
            
            templateItem.appendChild(img);
            templateItem.addEventListener('click', () => loadTemplate(template.src));
            
            templatesContainer.appendChild(templateItem);
        });
    }
    
    // Load a template image
    function loadTemplate(src) {
        const img = new Image();
        
        img.onload = function() {
            // Clear existing content
            images = [];
            texts = [];
            
            // Calculate size to fit canvas while maintaining aspect ratio
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            let width = img.width;
            let height = img.height;
            
            if (width > canvasWidth - 40 || height > canvasHeight - 40) {
                const ratio = Math.min(
                    (canvasWidth - 40) / width,
                    (canvasHeight - 40) / height
                );
                width *= ratio;
                height *= ratio;
            }
            
            const newImage = {
                src: src,
                width: img.width,
                height: img.height,
                x: (canvasWidth - width) / 2,
                y: (canvasHeight - height) / 2,
                scaleFactor: width / img.width
            };
            
            images.push(newImage);
            
            // Add default top and bottom text for meme templates
            texts = [
                {
                    content: 'TOP TEXT',
                    x: canvasWidth / 2 - 150,
                    y: 20,
                    fontSize: 36,
                    color: '#ffffff'
                },
                {
                    content: 'BOTTOM TEXT',
                    x: canvasWidth / 2 - 150,
                    y: canvasHeight - 70,
                    fontSize: 36,
                    color: '#ffffff'
                }
            ];
            
            saveState();
            updateUI();
            hideDropZone();
        };
        
        img.src = src;
    }
    
    // Helper functions
    function handleDragOver(e) {
        e.preventDefault();
        canvas.style.borderColor = '#4CAF50';
        dropMessage.textContent = 'Release to add image';
    }
    
    function handleDrop(e) {
        e.preventDefault();
        canvas.style.borderColor = '#ccc';
        dropMessage.textContent = 'Upload image or choose a template';
        
        if (e.dataTransfer.files.length > 0) {
            const file = e.dataTransfer.files[0];
            if (file.type.startsWith('image/')) {
                processImageFile(file);
            }
        }
    }
    
    function handleFileUpload(e) {
        if (e.target.files.length > 0) {
            const file = e.target.files[0];
            if (file.type.startsWith('image/')) {
                processImageFile(file);
            }
        }
    }
    
    function processImageFile(file) {
        showLoading("Loading image...");
        
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                // Calculate size to fit canvas while maintaining aspect ratio
                const canvasWidth = canvas.clientWidth;
                const canvasHeight = canvas.clientHeight;
                let width = img.width;
                let height = img.height;
                
                if (width > canvasWidth - 40 || height > canvasHeight - 40) {
                    const ratio = Math.min(
                        (canvasWidth - 40) / width,
                        (canvasHeight - 40) / height
                    );
                    width *= ratio;
                    height *= ratio;
                }
                
                const newImage = {
                    src: event.target.result,
                    width: img.width,
                    height: img.height,
                    x: (canvasWidth - width) / 2,
                    y: (canvasHeight - height) / 2,
                    scaleFactor: width / img.width
                };
                
                images.push(newImage);
                saveState();
                updateUI();
                hideDropZone();
                hideLoading();
            };
            
            img.onerror = function() {
                hideLoading();
                alert("Error loading image. Please try another file.");
            };
            
            img.src = event.target.result;
        };
        
        reader.readAsDataURL(file);
    }
    
    function hideDropZone() {
        const dropZone = canvas.querySelector('.drop-zone');
        if (dropZone && images.length > 0) {
            dropZone.style.display = 'none';
        }
    }
    
    function showDropZone() {
        const dropZone = canvas.querySelector('.drop-zone');
        if (dropZone) {
            dropZone.style.display = 'flex';
        }
    }
    
    function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Reset selected state
        selectedImageIndex = -1;
        selectedTextIndex = -1;
        
        // First check if clicked on a resize handle
        const resizeHandle = e.target.closest('.resize-handle');
        if (resizeHandle) {
            isResizing = true;
            resizeDirection = resizeHandle.classList.contains('nw') ? 'nw' : 
                              resizeHandle.classList.contains('ne') ? 'ne' : 
                              resizeHandle.classList.contains('sw') ? 'sw' : 'se';
            
            const imageElement = resizeHandle.parentElement;
            const imageIndex = Array.from(canvas.querySelectorAll('.image-item')).indexOf(imageElement);
            
            if (imageIndex !== -1) {
                selectedImageIndex = imageIndex;
                dragStartX = x;
                dragStartY = y;
                const img = images[selectedImageIndex];
                initialWidth = img.width * img.scaleFactor;
                initialHeight = img.height * img.scaleFactor;
                initialX = img.x;
                initialY = img.y;
                
                updateControls();
                updateUI();
                return;
            }
        }
        
        // Then check if clicked on a text element (higher z-index)
        for (let i = texts.length - 1; i >= 0; i--) {
            const text = texts[i];
            const textElement = document.getElementById(`text-${i}`);
            if (textElement) {
                const textRect = textElement.getBoundingClientRect();
                const relativeRect = {
                    left: textRect.left - rect.left,
                    top: textRect.top - rect.top,
                    right: textRect.right - rect.left,
                    bottom: textRect.bottom - rect.top
                };
                
                if (x >= relativeRect.left && x <= relativeRect.right && 
                    y >= relativeRect.top && y <= relativeRect.bottom) {
                    isDragging = true;
                    selectedTextIndex = i;
                    dragStartX = x;
                    dragStartY = y;
                    initialX = text.x;
                    initialY = text.y;
                    
                    updateControls();
                    updateUI();
                    return;
                }
            }
        }
        
        // Then check if clicked on an image
        for (let i = images.length - 1; i >= 0; i--) {
            const img = images[i];
            const imgWidth = img.width * img.scaleFactor;
            const imgHeight = img.height * img.scaleFactor;
            
            if (
                x >= img.x && 
                x <= img.x + imgWidth && 
                y >= img.y && 
                y <= img.y + imgHeight
            ) {
                isDragging = true;
                selectedImageIndex = i;
                dragStartX = x;
                dragStartY = y;
                initialX = img.x;
                initialY = img.y;
                
                // Move selected image to top
                const selectedImage = images[i];
                images.splice(i, 1);
                images.push(selectedImage);
                selectedImageIndex = images.length - 1;
                
                updateControls();
                updateUI();
                break;
            }
        }
    }
    
    function handleMouseMove(e) {
        if (!isDragging && !isResizing) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const dx = x - dragStartX;
        const dy = y - dragStartY;
        
        if (isDragging) {
            if (selectedImageIndex !== -1) {
                const selectedImage = images[selectedImageIndex];
                selectedImage.x = initialX + dx;
                selectedImage.y = initialY + dy;
            } else if (selectedTextIndex !== -1) {
                const selectedText = texts[selectedTextIndex];
                selectedText.x = initialX + dx;
                selectedText.y = initialY + dy;
            }
        } else if (isResizing && selectedImageIndex !== -1) {
            // Handle image resizing based on the resize direction
            const img = images[selectedImageIndex];
            const aspectRatio = img.width / img.height;
            
            let newWidth, newHeight, newX, newY;
            
            switch (resizeDirection) {
                case 'se':
                    newWidth = Math.max(50, initialWidth + dx);
                    newHeight = newWidth / aspectRatio;
                    newX = initialX;
                    newY = initialY;
                    break;
                case 'sw':
                    newWidth = Math.max(50, initialWidth - dx);
                    newHeight = newWidth / aspectRatio;
                    newX = initialX + initialWidth - newWidth;
                    newY = initialY;
                    break;
                case 'ne':
                    newWidth = Math.max(50, initialWidth + dx);
                    newHeight = newWidth / aspectRatio;
                    newX = initialX;
                    newY = initialY + initialHeight - newHeight;
                    break;
                case 'nw':
                    newWidth = Math.max(50, initialWidth - dx);
                    newHeight = newWidth / aspectRatio;
                    newX = initialX + initialWidth - newWidth;
                    newY = initialY + initialHeight - newHeight;
                    break;
            }
            
            img.scaleFactor = newWidth / img.width;
            img.x = newX;
            img.y = newY;
            
            // Update the scale slider
            const scalePercent = Math.round(img.scaleFactor * 100);
            imageScale.value = scalePercent;
            imageScaleValue.textContent = `${scalePercent}%`;
        }
        
        updateUI();
    }
    
    function handleMouseUp(e) {
        if (isDragging || isResizing) {
            isDragging = false;
            isResizing = false;
            saveState();
            updateUI();
        }
    }
    
    function handleUndo() {
        if (currentHistoryIndex > 0) {
            currentHistoryIndex--;
            restoreState(historyStates[currentHistoryIndex]);
            updateUI();
            updateControls();
            updateButtonState();
        }
    }
    
    function handleRedo() {
        if (currentHistoryIndex < historyStates.length - 1) {
            currentHistoryIndex++;
            restoreState(historyStates[currentHistoryIndex]);
            updateUI();
            updateControls();
            updateButtonState();
        }
    }
    
    function saveState() {
        // Truncate forward history if we're not at the end
        if (currentHistoryIndex < historyStates.length - 1) {
            historyStates = historyStates.slice(0, currentHistoryIndex + 1);
        }
        
        // Create a deep copy of the images and texts arrays
        const imagesDeepCopy = JSON.parse(JSON.stringify(images));
        const textsDeepCopy = JSON.parse(JSON.stringify(texts));
        
        // Add the state to history
        historyStates.push({
            images: imagesDeepCopy,
            texts: textsDeepCopy
        });
        currentHistoryIndex = historyStates.length - 1;
        
        updateButtonState();
    }
    
    function restoreState(state) {
        images = JSON.parse(JSON.stringify(state.images || []));
        texts = JSON.parse(JSON.stringify(state.texts || []));
    }
    
    function updateButtonState() {
        undoBtn.disabled = currentHistoryIndex <= 0;
        redoBtn.disabled = currentHistoryIndex >= historyStates.length - 1;
        exportBtn.disabled = images.length === 0;
    }
    
    function updateUI() {
        // Clear canvas (except drop zone)
        const dropZone = canvas.querySelector('.drop-zone');
        const imageElements = document.querySelectorAll('.image-item');
        imageElements.forEach(el => el.remove());
        
        // Remove all text elements
        const textElements = document.querySelectorAll('.meme-text');
        textElements.forEach(el => el.remove());
        
        // Remove all resize handles
        const resizeHandles = document.querySelectorAll('.resize-handle');
        resizeHandles.forEach(el => el.remove());
        
        // Show/hide drop zone
        if (dropZone) {
            dropZone.style.display = images.length > 0 ? 'none' : 'flex';
        }
        
        // Add images
        images.forEach((img, index) => {
            const imgElement = document.createElement('img');
            imgElement.src = img.src;
            imgElement.classList.add('image-item');
            if (index === selectedImageIndex) {
                imgElement.classList.add('selected');
            }
            
            imgElement.style.width = `${img.width * img.scaleFactor}px`;
            imgElement.style.height = `${img.height * img.scaleFactor}px`;
            imgElement.style.left = `${img.x}px`;
            imgElement.style.top = `${img.y}px`;
            
            canvas.appendChild(imgElement);
            
            // Add resize handles for selected image
            if (index === selectedImageIndex) {
                const directions = ['nw', 'ne', 'sw', 'se'];
                directions.forEach(dir => {
                    const handle = document.createElement('div');
                    handle.classList.add('resize-handle', dir);
                    imgElement.appendChild(handle);
                });
            }
        });
        
        // Add text elements
        texts.forEach((text, index) => {
            const textElement = document.createElement('div');
            textElement.id = `text-${index}`;
            textElement.classList.add('meme-text');
            if (index === selectedTextIndex) {
                textElement.classList.add('selected');
            }
            
            textElement.textContent = text.content;
            textElement.style.left = `${text.x}px`;
            textElement.style.top = `${text.y}px`;
            textElement.style.fontSize = `${text.fontSize}px`;
            textElement.style.color = text.color;
            
            canvas.appendChild(textElement);
        });
        
        updateButtonState();
    }
    
    // Text functions
    function addNewText() {
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        
        texts.push({
            content: 'YOUR TEXT HERE',
            x: canvasWidth / 2 - 150,
            y: canvasHeight / 2 - 20,
            fontSize: 36,
            color: '#ffffff'
        });
        
        selectedTextIndex = texts.length - 1;
        saveState();
        updateUI();
        updateControls();
    }
    
    function updateControls() {
        // Hide both control panels by default
        textControls.style.display = 'none';
        imageControls.style.display = 'none';
        
        // Update text controls
        if (selectedTextIndex !== -1) {
            const text = texts[selectedTextIndex];
            textControls.style.display = 'block';
            textInput.value = text.content;
            textSize.value = text.fontSize;
            textSizeValue.textContent = `${text.fontSize}px`;
            textColor.value = text.color;
        }
        
        // Update image controls
        if (selectedImageIndex !== -1) {
            const img = images[selectedImageIndex];
            imageControls.style.display = 'block';
            const scalePercent = Math.round(img.scaleFactor * 100);
            imageScale.value = scalePercent;
            imageScaleValue.textContent = `${scalePercent}%`;
        }
    }
    
    function updateSelectedText() {
        if (selectedTextIndex !== -1) {
            texts[selectedTextIndex].content = textInput.value;
            updateUI();
        }
    }
    
    function updateTextSize() {
        if (selectedTextIndex !== -1) {
            textSizeValue.textContent = `${textSize.value}px`;
            texts[selectedTextIndex].fontSize = parseInt(textSize.value);
            updateUI();
        }
    }
    
    function updateTextColor() {
        if (selectedTextIndex !== -1) {
            texts[selectedTextIndex].color = textColor.value;
            updateUI();
        }
    }
    
    function updateImageScale() {
        if (selectedImageIndex !== -1) {
            const scalePercent = parseInt(imageScale.value);
            imageScaleValue.textContent = `${scalePercent}%`;
            
            const img = images[selectedImageIndex];
            const oldWidth = img.width * img.scaleFactor;
            const oldHeight = img.height * img.scaleFactor;
            
            img.scaleFactor = scalePercent / 100;
            
            // Adjust position to scale from center
            const newWidth = img.width * img.scaleFactor;
            const newHeight = img.height * img.scaleFactor;
            img.x += (oldWidth - newWidth) / 2;
            img.y += (oldHeight - newHeight) / 2;
            
            updateUI();
        }
    }
    
    function positionText(position) {
        if (selectedTextIndex === -1) return;
        
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        
        const text = texts[selectedTextIndex];
        const textElement = document.getElementById(`text-${selectedTextIndex}`);
        const textWidth = textElement ? textElement.offsetWidth : 300;
        
        // Center horizontally
        text.x = (canvasWidth - textWidth) / 2;
        
        // Position vertically
        switch (position) {
            case 'top':
                text.y = 20;
                break;
            case 'bottom':
                text.y = canvasHeight - textElement.offsetHeight - 20;
                break;
        }
        
        updateUI();
        saveState();
    }
    
    function deleteSelectedText() {
        if (selectedTextIndex !== -1) {
            texts.splice(selectedTextIndex, 1);
            selectedTextIndex = -1;
            saveState();
            updateUI();
            updateControls();
        }
    }
    
    function deleteSelectedImage() {
        if (selectedImageIndex !== -1) {
            images.splice(selectedImageIndex, 1);
            selectedImageIndex = -1;
            saveState();
            updateUI();
            updateControls();
            
            // Show drop zone if no images left
            if (images.length === 0) {
                showDropZone();
            }
        }
    }
    
    function bringSelectedImageToFront() {
        if (selectedImageIndex !== -1) {
            const selectedImage = images[selectedImageIndex];
            images.splice(selectedImageIndex, 1);
            images.push(selectedImage);
            selectedImageIndex = images.length - 1;
            updateUI();
            saveState();
        }
    }
    
    function sendSelectedImageToBack() {
        if (selectedImageIndex !== -1) {
            const selectedImage = images[selectedImageIndex];
            images.splice(selectedImageIndex, 1);
            images.unshift(selectedImage);
            selectedImageIndex = 0;
            updateUI();
            saveState();
        }
    }
    
    function exportAsPNG() {
        // Show loading indicator
        showLoading("Generating image...");
        
        // Temporarily hide any UI elements we don't want in the export
        document.querySelectorAll('.image-item').forEach(img => {
            img.classList.remove('selected');
        });
        
        document.querySelectorAll('.meme-text').forEach(text => {
            text.classList.remove('selected');
        });
        
        // Hide resize handles
        document.querySelectorAll('.resize-handle').forEach(handle => {
            handle.style.display = 'none';
        });
        
        const dropZone = canvas.querySelector('.drop-zone');
        if (dropZone) {
            dropZone.style.display = 'none';
        }
        
        // Save the original border style and temporarily remove it
        const originalBorder = canvas.style.border;
        canvas.style.border = 'none';
        
        // Use html2canvas to create an image from our canvas
        html2canvas(canvas, {
            backgroundColor: 'white',
            scale: 2, // For better quality
            logging: false,
            removeContainer: true,
        }).then(function(renderedCanvas) {
            // Create a link to download the image
            const link = document.createElement('a');
            link.download = 'meme.png';
            link.href = renderedCanvas.toDataURL('image/png');
            link.click();
            
            // Restore original border style
            canvas.style.border = originalBorder;
            
            // Restore UI elements
            if (dropZone && images.length === 0) {
                dropZone.style.display = 'flex';
            }
            
            // Show resize handles again
            document.querySelectorAll('.resize-handle').forEach(handle => {
                handle.style.display = 'block';
            });
            
            // Restore selected state
            updateUI();
            
            // Hide loading indicator
            hideLoading();
        }).catch(error => {
            console.error("Error exporting image:", error);
            hideLoading();
            alert("Error exporting image. Please try again.");
        });
    }
    
    // Helper functions for UI
    function showLoading(message = "Loading...") {
        // Create loading overlay if it doesn't exist
        let loading = document.querySelector('.loading');
        if (!loading) {
            loading = document.createElement('div');
            loading.className = 'loading';
            
            const loadingContent = document.createElement('div');
            loadingContent.className = 'loading-content';
            
            const spinner = document.createElement('div');
            spinner.className = 'spinner';
            
            const messageElement = document.createElement('div');
            messageElement.id = 'loading-message';
            messageElement.textContent = message;
            
            loadingContent.appendChild(spinner);
            loadingContent.appendChild(messageElement);
            loading.appendChild(loadingContent);
            
            document.body.appendChild(loading);
        } else {
            document.getElementById('loading-message').textContent = message;
            loading.style.display = 'flex';
        }
    }
    
    function hideLoading() {
        const loading = document.querySelector('.loading');
        if (loading) {
            loading.style.display = 'none';
        }
    }
    
    // New functions for the added features
    
    // Reset the canvas to its initial state
    function resetCanvas() {
        // Confirm before resetting
        if (images.length > 0 || texts.length > 0) {
            if (!confirm('This will clear all images and text. Are you sure?')) {
                return;
            }
        }
        
        // Clear images and texts
        images = [];
        texts = [];
        
        // Reset selection
        selectedImageIndex = -1;
        selectedTextIndex = -1;
        
        // Save state and update UI
        saveState();
        updateUI();
        updateControls();
        showDropZone();
    }
    
    // Toggle dark mode
    function toggleDarkMode() {
        isDarkMode = !isDarkMode;
        
        // Toggle dark mode class on body
        document.body.classList.toggle('light-mode', !isDarkMode);
        document.body.classList.toggle('dark-mode', isDarkMode);
        
        // Update icon
        if (isDarkMode) {
            darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
            darkModeToggle.title = "Switch to Light Mode";
        } else {
            darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
            darkModeToggle.title = "Switch to Dark Mode";
        }
    }
    
    // Update the dark mode toggle icon initially
    darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
    darkModeToggle.title = "Switch to Light Mode";
    
    // Update canvas aspect ratio based on selection
    function updateCanvasAspectRatio(ratio) {
        let width, height;
        
        // Handle both string (e.g., "16:9") and numeric (e.g., 1.78) ratio formats
        if (typeof ratio === 'string') {
            if (ratio.includes(':')) {
                // Split "16:9" format into numbers
                const parts = ratio.split(':');
                width = parseFloat(parts[0]);
                height = parseFloat(parts[1]);
            } else {
                // Handle direct number as string, e.g., "1"
                const numericRatio = parseFloat(ratio);
                if (numericRatio === 1) {
                    width = height = 1; // Square
                } else if (numericRatio > 1) {
                    // Landscape
                    width = numericRatio;
                    height = 1;
                } else {
                    // Portrait
                    width = 1;
                    height = 1 / numericRatio;
                }
            }
        } else if (typeof ratio === 'number') {
            // Handle direct number input
            if (ratio === 1) {
                width = height = 1; // Square
            } else if (ratio > 1) {
                // Landscape
                width = ratio;
                height = 1;
            } else {
                // Portrait
                width = 1;
                height = 1 / ratio;
            }
        } else {
            // Default to square if invalid input
            width = height = 1;
        }
        
        // Store the aspect ratio for use in other functions
        currentAspectRatio = { width, height };
        
        // Update aspect ratio dropdown if it exists
        const aspectRatioSelect = document.getElementById('aspect-ratio');
        if (aspectRatioSelect) {
            // Find the option that most closely matches our ratio
            const numericRatio = width / height;
            let closestOption = null;
            let smallestDiff = Infinity;
            
            // Check each option to find closest match
            Array.from(aspectRatioSelect.options).forEach(option => {
                const optionValue = parseFloat(option.value);
                if (!isNaN(optionValue)) {
                    const diff = Math.abs(optionValue - numericRatio);
                    if (diff < smallestDiff) {
                        smallestDiff = diff;
                        closestOption = option.value;
                    }
                }
            });
            
            if (closestOption !== null) {
                aspectRatioSelect.value = closestOption;
            }
        }
        
        // Update aspect ratio toggles if they exist
        const aspectRatioToggles = document.querySelectorAll('.aspect-toggle');
        aspectRatioToggles.forEach(toggle => {
            const toggleRatio = toggle.dataset.ratio;
            let toggleMatch = false;
            
            if (toggleRatio && toggleRatio.includes(':')) {
                const parts = toggleRatio.split(':');
                const toggleWidth = parseFloat(parts[0]);
                const toggleHeight = parseFloat(parts[1]);
                
                // Check if this toggle matches our current ratio (with small margin for floating point)
                if (Math.abs((toggleWidth / toggleHeight) - (width / height)) < 0.01) {
                    toggleMatch = true;
                }
            }
            
            // Update active state
            toggle.classList.toggle('active', toggleMatch);
        });
        
        // Resize the canvas with the new aspect ratio
        const dimensions = updateCanvasSize();
        
        // Log the actual dimensions for debugging
        console.log(`Canvas resized to ${dimensions.width} x ${dimensions.height} (aspect ratio: ${width}:${height})`);
        
        // Update image and text positions to fit new canvas size
        if (images.length > 0 || texts.length > 0) {
            arrangeImagesOptimally();
        }
        
        // Return dimensions
        return dimensions;
    }
    
    // Add unified dimension constants at the top level
    const CANVAS_DIMENSIONS = {
        // Maximum dimensions (should match CSS)
        MAX_WIDTH: 800,
        MAX_HEIGHT: 800,
        
        // Target size for square (1:1) aspect ratio
        SQUARE_SIZE: 625,
        
        // Device breakpoints (should match CSS media queries)
        BREAKPOINTS: {
            SMALL_MOBILE: 350,
            MOBILE: 480,
            TABLET: 768,
            DESKTOP: 1024,
            LARGE_DESKTOP: 1200
        },
        
        // Minimum dimensions for different devices
        MIN_DIMENSIONS: {
            SMALL_MOBILE: 250,
            MOBILE: 280,
            TABLET: 350,
            DESKTOP: 400
        }
    };

    // Replace the updateCanvasSize function with this improved version
    function updateCanvasSize() {
        const ratio = currentAspectRatio.width / currentAspectRatio.height;
        
        // Determine device type using the same breakpoints as our CSS
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const isLandscape = windowWidth > windowHeight;
        
        // Use matchMedia for consistent breakpoint detection with CSS
        const isSmallMobile = window.matchMedia(`(max-width: ${CANVAS_DIMENSIONS.BREAKPOINTS.SMALL_MOBILE}px)`).matches;
        const isMobile = window.matchMedia(`(max-width: ${CANVAS_DIMENSIONS.BREAKPOINTS.MOBILE}px)`).matches;
        const isTablet = window.matchMedia(`(max-width: ${CANVAS_DIMENSIONS.BREAKPOINTS.TABLET}px)`).matches && !isMobile;
        const isLargeDesktop = window.matchMedia(`(min-width: ${CANVAS_DIMENSIONS.BREAKPOINTS.LARGE_DESKTOP}px)`).matches;
        
        // Get the canvas container's available width
        const container = canvas.closest('.canvas-container');
        const availableWidth = container ? container.clientWidth : windowWidth;
        
        // Calculate appropriate percentage of available width based on device
        let widthPercentage, heightPercentage;
        if (isSmallMobile) {
            widthPercentage = 0.92;
            heightPercentage = isLandscape ? 0.7 : 0.55;
        } else if (isMobile) {
            widthPercentage = 0.85;
            heightPercentage = isLandscape ? 0.75 : 0.65;
        } else if (isTablet) {
            widthPercentage = 0.8;
            heightPercentage = 0.7;
        } else if (isLargeDesktop) {
            widthPercentage = 0.65;
            heightPercentage = 0.75;
        } else {
            // Standard desktop
            widthPercentage = 0.7;
            heightPercentage = 0.7;
        }
        
        // Set appropriate minimum dimensions based on device
        const minSize = isSmallMobile ? CANVAS_DIMENSIONS.MIN_DIMENSIONS.SMALL_MOBILE : 
                      isMobile ? CANVAS_DIMENSIONS.MIN_DIMENSIONS.MOBILE : 
                      isTablet ? CANVAS_DIMENSIONS.MIN_DIMENSIONS.TABLET : 
                      CANVAS_DIMENSIONS.MIN_DIMENSIONS.DESKTOP;
        
        // Maximum dimensions should match our CSS constraints
        // For mobile/tablet, use values from media queries
        let maxWidth, maxHeight;
        if (isSmallMobile) {
            maxWidth = maxHeight = 300; // From CSS @media max-width: 350px
        } else if (isMobile) {
            maxWidth = maxHeight = 400; // From CSS @media max-width: 480px
        } else if (isTablet) {
            maxWidth = maxHeight = 600; // From CSS @media max-width: 768px
        } else if (isLargeDesktop) {
            maxWidth = maxHeight = CANVAS_DIMENSIONS.MAX_WIDTH; // 800px by default
        } else {
            maxWidth = maxHeight = CANVAS_DIMENSIONS.MAX_WIDTH; // 800px by default
        }
        
        // Calculate target width and height based on available space
        let targetWidth = Math.min(availableWidth * widthPercentage, maxWidth);
        let targetHeight = Math.min(windowHeight * heightPercentage, maxHeight);
        
        // Handle square aspect ratio (1:1) specially and consistently
        if (Math.abs(ratio - 1) < 0.01) { // Using a small epsilon for floating point comparison
            // For square aspect ratio, use our target square size if it fits
            const squareSize = Math.min(targetWidth, targetHeight);
            
            // Check if our preferred square size (625px) would fit
            if (CANVAS_DIMENSIONS.SQUARE_SIZE <= squareSize && CANVAS_DIMENSIONS.SQUARE_SIZE <= maxWidth) {
                targetWidth = targetHeight = CANVAS_DIMENSIONS.SQUARE_SIZE;
            } else {
                // Otherwise use the maximum square that fits
                targetWidth = targetHeight = squareSize;
            }
        } else {
            // For non-square aspect ratios, calculate dimensions while preserving ratio
            if (ratio > 1) {
                // Landscape orientation
                targetHeight = Math.min(targetHeight, targetWidth / ratio);
                targetWidth = targetHeight * ratio;
            } else {
                // Portrait orientation
                targetWidth = Math.min(targetWidth, targetHeight * ratio);
                targetHeight = targetWidth / ratio;
            }
            
            // Ensure dimensions don't exceed max width/height
            if (targetWidth > maxWidth) {
                targetWidth = maxWidth;
                targetHeight = targetWidth / ratio;
            }
            if (targetHeight > maxHeight) {
                targetHeight = maxHeight;
                targetWidth = targetHeight * ratio;
            }
            
            // Enforce minimum dimensions while preserving aspect ratio
            if (targetWidth < minSize) {
                targetWidth = minSize;
                targetHeight = targetWidth / ratio;
            }
            if (targetHeight < minSize) {
                targetHeight = minSize;
                targetWidth = targetHeight * ratio;
            }
        }
        
        // Round dimensions to prevent sub-pixel rendering issues
        // Always round to even numbers for better pixel rendering
        const finalWidth = Math.round(targetWidth);
        const finalHeight = Math.round(targetHeight);
        const evenWidth = finalWidth % 2 !== 0 ? finalWidth - 1 : finalWidth;
        const evenHeight = finalHeight % 2 !== 0 ? finalHeight - 1 : finalHeight;
        
        // Apply dimensions to the canvas
        canvas.style.width = `${evenWidth}px`;
        canvas.style.height = `${evenHeight}px`;
        
        // Update canvas dimensions display with accurate values
        const canvasDimensions = document.getElementById('canvas-dimensions');
        if (canvasDimensions) {
            canvasDimensions.textContent = `${evenWidth} x ${evenHeight}`;
        }
        
        // Apply appropriate CSS classes based on device type
        canvas.classList.remove('mobile-view', 'tablet-view', 'desktop-view');
        if (isMobile) {
            canvas.classList.add('mobile-view');
        } else if (isTablet) {
            canvas.classList.add('tablet-view');
        } else {
            canvas.classList.add('desktop-view');
        }
        
        // Return the actual dimensions for any functions that need them
        return {
            width: evenWidth,
            height: evenHeight
        };
    }
    
    // Optimal arrangement of images
    function arrangeImagesOptimally() {
        if (images.length === 0) return;
        
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        
        // Ensure the canvas dimensions are displayed correctly
        const canvasDimensions = document.getElementById('canvas-dimensions');
        if (canvasDimensions) {
            canvasDimensions.textContent = `${canvasWidth} x ${canvasHeight}`;
        }
        
        // Use a dynamic padding that scales with the number of images
        // Fewer images = more padding, more images = less padding (min 5px)
        const basePadding = 15;
        const minPadding = 5;
        const padding = Math.max(basePadding - (images.length / 2), minPadding);
        
        // Create a working copy of images for manipulation
        let workingImages = [...images];
        
        // Shuffle the images first to create different layouts each time
        workingImages = shuffleArray(workingImages);
        
        // Sort images by area (larger images first)
        workingImages.sort((a, b) => (b.width * b.height) - (a.width * a.height));
        
        // Calculate total image area and canvas area
        let totalImageArea = 0;
        workingImages.forEach(img => {
            totalImageArea += img.width * img.height;
        });
        
        const canvasArea = canvasWidth * canvasHeight;
        
        // Calculate average image area - this is our target for equal sizing
        const avgImageArea = totalImageArea / workingImages.length;
        
        // Target scale factor to make images closer to equal visual size
        // Increase utilization to 90% of canvas for better space usage
        const targetScale = Math.sqrt((canvasArea * 0.9) / totalImageArea);
        
        // Calculate ideal display area per image (in pixels)
        const idealArea = (canvasArea * 0.9) / workingImages.length;
        const idealSideLength = Math.sqrt(idealArea);
        
        // Assign importance to each image
        workingImages.forEach((img, index) => {
            // Original importance calculation
            const sizeFactor = (img.width * img.height) / (totalImageArea / workingImages.length);
            const positionFactor = 1 - (index / workingImages.length);
            
            // Equal sizing gets higher weighting now (0.7 vs 0.3 for traditional factors)
            img.importance = (sizeFactor * 0.15) + (positionFactor * 0.15) + 0.7;
            
            // Store the ideal scale factor for this image to achieve the ideal area
            img.idealScaleFactor = Math.sqrt(idealArea / (img.width * img.height));
        });
        
        // Initialize layout with improved treemap algorithm
        const result = divideSpaceAndPlace(
            workingImages, 
            padding, 
            padding, 
            canvasWidth - padding * 2, 
            canvasHeight - padding * 2,
            targetScale,
            idealSideLength
        );
        
        // Apply positions from our layout algorithm
        result.forEach((layout, index) => {
            const img = workingImages[index];
            img.x = layout.x;
            img.y = layout.y;
            img.scaleFactor = layout.scaleFactor;
        });
        
        // Perform collision detection and resolution
        resolveCollisions(workingImages);
        
        // Apply the working image changes to the actual images array
        // We need to map working images back to their original positions
        workingImages.forEach((workingImg) => {
            // Find the original image that matches this working image
            const originalImg = images.find(img => 
                img.src === workingImg.src && 
                img.width === workingImg.width && 
                img.height === workingImg.height
            );
            
            if (originalImg) {
                originalImg.x = workingImg.x;
                originalImg.y = workingImg.y;
                originalImg.scaleFactor = workingImg.scaleFactor;
            }
        });
        
        // Also reposition text elements if they exist
        if (texts.length > 0) {
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            
            texts.forEach(text => {
                // If text is at top, keep it at top
                if (text.y < canvasHeight * 0.25) {
                    text.y = 20;
                    text.x = (canvasWidth - 300) / 2; // Approximate width
                } 
                // If text is at bottom, keep it at bottom
                else if (text.y > canvasHeight * 0.75) {
                    text.y = canvasHeight - 70;
                    text.x = (canvasWidth - 300) / 2; // Approximate width
                }
                // Otherwise, try to keep it centered
                else {
                    text.y = (canvasHeight - 36) / 2; // Approximate font size
                    text.x = (canvasWidth - 300) / 2; // Approximate width
                }
            });
        }
        
        saveState();
        updateUI();
        
        // Recursive function to divide space and place images with improved collision avoidance
        function divideSpaceAndPlace(imagesToPlace, x, y, width, height, baseScale, idealSize) {
            // Base case: if we have only one image, it gets the entire space
            if (imagesToPlace.length === 1) {
                const img = imagesToPlace[0];
                const imgAspect = img.width / img.height;
                
                // Calculate the largest size that fits in the available space
                let scaleFactor;
                if (imgAspect > width / height) {
                    // Width constrained
                    scaleFactor = (width - padding * 2) / img.width;
                } else {
                    // Height constrained
                    scaleFactor = (height - padding * 2) / img.height;
                }
                
                // Balance between fitting the space and achieving ideal size
                // Target more equal sizing (now weighted at 70%)
                const sizeEqualityFactor = 0.7;
                const spatialFitFactor = 0.3;
                
                // Calculate a scale factor that targets the ideal size
                const idealScaleFactor = img.idealScaleFactor || baseScale;
                
                // Blend between the max fit scale and ideal scale based on our weighting
                const blendedScale = (scaleFactor * spatialFitFactor) + (idealScaleFactor * sizeEqualityFactor);
                
                // Ensure minimum scale factor (0.7 of base for better visibility)
                const finalScale = Math.max(blendedScale, baseScale * 0.7);
                
                // Center the image in available space
                const scaledWidth = img.width * finalScale;
                const scaledHeight = img.height * finalScale;
                const centerX = x + (width - scaledWidth) / 2;
                const centerY = y + (height - scaledHeight) / 2;
                
                return [{
                    x: centerX,
                    y: centerY,
                    width: scaledWidth,
                    height: scaledHeight,
                    scaleFactor: finalScale
                }];
            }
            
            // Divide images into two groups by total area
            const midpoint = findBalancedSplit(imagesToPlace, idealSize);
            const group1 = imagesToPlace.slice(0, midpoint);
            const group2 = imagesToPlace.slice(midpoint);
            
            // Calculate total area of each group
            let area1 = 0, area2 = 0;
            group1.forEach(img => area1 += img.width * img.height);
            group2.forEach(img => area2 += img.width * img.height);
            
            // Improved space division ratio calculation
            // Blend count-based and area-based ratios (favoring count for more equality)
            const countRatio = group1.length / imagesToPlace.length;
            const areaRatio = area1 / (area1 + area2);
            
            // Balance between count and area (80% count, 20% area) for more consistent sizing
            const ratio = (countRatio * 0.8) + (areaRatio * 0.2);
            
            // Calculate weighted average aspect ratios for each group
            let group1AspectRatio = 0;
            let group2AspectRatio = 0;
            
            group1.forEach(img => {
                const weight = (img.width * img.height) / area1;
                group1AspectRatio += (img.width / img.height) * weight;
            });
            
            group2.forEach(img => {
                const weight = (img.width * img.height) / area2;
                group2AspectRatio += (img.width / img.height) * weight;
            });
            
            // Calculate scores for both directions with improved weights for better fitting
            const horizontalFit = Math.abs(group1AspectRatio - (width * ratio) / height) + 
                                Math.abs(group2AspectRatio - (width * (1-ratio)) / height));
            
            const verticalFit = Math.abs(group1AspectRatio - width / (height * ratio)) + 
                              Math.abs(group2AspectRatio - width / (height * (1-ratio)));
            
            // Add a bias based on container shape to avoid thin slices
            const containerAspect = width / height;
            
            // Calculate scores for both directions with improved weights for better fitting
            const horizontalScore = horizontalFit * (containerAspect < 1 ? 1.1 : 0.9);
            const verticalScore = verticalFit * (containerAspect > 1 ? 1.1 : 0.9);
            
            // Ensure the padding is consistent and proportional to the space
            const effectivePadding = Math.min(padding, Math.min(width, height) * 0.05);
            
            if (horizontalScore <= verticalScore) {
                // Calculate split point with proper padding consideration
                const effectiveWidth = width - effectivePadding; // Account for padding space
                const splitX = x + Math.floor(effectiveWidth * ratio);
                
                // Ensure enough space on both sides (at least 2x padding)
                const adjustedSplitX = Math.min(
                    Math.max(splitX, x + padding * 2),
                    x + width - padding * 2
                );
                
                group1Results = divideSpaceAndPlace(
                    group1, 
                    x, 
                    y, 
                    adjustedSplitX - x - effectivePadding/2, 
                    height, 
                    baseScale, 
                    idealSize
                );
                
                group2Results = divideSpaceAndPlace(
                    group2, 
                    adjustedSplitX + effectivePadding/2, 
                    y, 
                    x + width - adjustedSplitX - effectivePadding/2, 
                    height, 
                    baseScale, 
                    idealSize
                );
            } else {
                // Calculate split point with proper padding consideration
                const effectiveHeight = height - effectivePadding; // Account for padding space
                const splitY = y + Math.floor(effectiveHeight * ratio);
                
                // Ensure enough space on both sides (at least 2x padding)
                const adjustedSplitY = Math.min(
                    Math.max(splitY, y + padding * 2),
                    y + height - padding * 2
                );
                
                group1Results = divideSpaceAndPlace(
                    group1, 
                    x, 
                    y, 
                    width, 
                    adjustedSplitY - y - effectivePadding/2, 
                    baseScale, 
                    idealSize
                );
                
                group2Results = divideSpaceAndPlace(
                    group2, 
                    x, 
                    adjustedSplitY + effectivePadding/2, 
                    width, 
                    y + height - adjustedSplitY - effectivePadding/2, 
                    baseScale, 
                    idealSize
                );
            }
            
            return [...group1Results, ...group2Results];
        }
        
        // Helper function to find the balanced split point - refined for better balance
        function findBalancedSplit(items, idealSize) {
            if (items.length <= 1) return 1;
            
            // For very small sets, just divide in half
            if (items.length <= 3) return Math.ceil(items.length / 2);
            
            // Calculate total area and aspect information
            let totalArea = 0;
            let totalAspectWeight = 0;
            
            items.forEach(img => {
                const area = img.width * img.height;
                totalArea += area;
                totalAspectWeight += (img.width / img.height) * area;
            });
            
            const halfArea = totalArea / 2;
            const targetAspect = totalAspectWeight / totalArea;
            const halfCount = items.length / 2;
            
            // Find split point that balances area, count, and aspect ratios
            let bestSplitIndex = 1;
            let bestScore = Infinity;
            let currentArea = 0;
            let currentAspectWeight = 0;
            
            for (let i = 0; i < items.length - 1; i++) {
                const img = items[i];
                const imgArea = img.width * img.height;
                
                currentArea += imgArea;
                currentAspectWeight += (img.width / img.height) * imgArea;
                
                // Score based on how well this split balances area
                const areaScore = Math.abs(currentArea - halfArea) / totalArea;
                
                // Get aspect ratio for each group
                const group1Aspect = currentAspectWeight / currentArea;
                const group2Aspect = (totalAspectWeight - currentAspectWeight) / (totalArea - currentArea);
                
                // Score based on how well aspects in each group match the target
                const aspectScore = Math.abs(group1Aspect - targetAspect) + Math.abs(group2Aspect - targetAspect);
                
                // Score based on how evenly this splits the count (important for equal sizing)
                const countScore = Math.abs((i + 1) - halfCount) / items.length;
                
                // Combined score (lower is better) with count having the highest weight for equal sizing
                // Increased weighting for count to 70% to prioritize equal number of images in each group
                const score = (areaScore * 0.15) + (aspectScore * 0.15) + (countScore * 0.7);
                
                if (score < bestScore) {
                    bestScore = score;
                    bestSplitIndex = i + 1;
                }
            }
            
            return bestSplitIndex;
        }
        
        // New function to detect and resolve collisions between images
        function resolveCollisions(imageArray) {
            const collisionPadding = padding / 2; // Minimum space between images
            let collisionsResolved = false;
            const maxIterations = 10; // Prevent infinite loops
            let iterations = 0;
            
            // Loop until no more collisions are found or max iterations reached
            while (!collisionsResolved && iterations < maxIterations) {
                collisionsResolved = true;
                iterations++;
                
                // Check each pair of images for collisions
                for (let i = 0; i < imageArray.length; i++) {
                    const img1 = imageArray[i];
                    
                    // Calculate the rectangle for this image
                    const rect1 = {
                        left: img1.x,
                        right: img1.x + (img1.width * img1.scaleFactor),
                        top: img1.y,
                        bottom: img1.y + (img1.height * img1.scaleFactor)
                    };
                    
                    for (let j = i + 1; j < imageArray.length; j++) {
                        const img2 = imageArray[j];
                        
                        // Calculate the rectangle for the other image
                        const rect2 = {
                            left: img2.x,
                            right: img2.x + (img2.width * img2.scaleFactor),
                            top: img2.y,
                            bottom: img2.y + (img2.height * img2.scaleFactor)
                        };
                        
                        // Check if the rectangles overlap
                        if (rect1.left < rect2.right + collisionPadding &&
                            rect1.right + collisionPadding > rect2.left &&
                            rect1.top < rect2.bottom + collisionPadding &&
                            rect1.bottom + collisionPadding > rect2.top) {
                            
                            // We have a collision, so we need to resolve it
                            collisionsResolved = false;
                            
                            // Calculate overlaps in each direction
                            const overlapLeft = rect2.right + collisionPadding - rect1.left;
                            const overlapRight = rect1.right + collisionPadding - rect2.left;
                            const overlapTop = rect2.bottom + collisionPadding - rect1.top;
                            const overlapBottom = rect1.bottom + collisionPadding - rect2.top;
                            
                            // Find the smallest overlap to resolve (minimum translation distance)
                            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                            
                            // Apply the smallest displacement for least disruptive motion
                            // Also consider importance of images when resolving collisions
                            const importance1 = img1.importance || 1;
                            const importance2 = img2.importance || 1;
                            const ratio1 = importance2 / (importance1 + importance2); // More important = less displacement
                            const ratio2 = importance1 / (importance1 + importance2);
                            
                            if (minOverlap === overlapLeft) {
                                img1.x -= overlapLeft * ratio1;
                                img2.x += overlapLeft * ratio2;
                            } else if (minOverlap === overlapRight) {
                                img1.x += overlapRight * ratio1;
                                img2.x -= overlapRight * ratio2;
                            } else if (minOverlap === overlapTop) {
                                img1.y -= overlapTop * ratio1;
                                img2.y += overlapTop * ratio2;
                            } else { // overlapBottom
                                img1.y += overlapBottom * ratio1;
                                img2.y -= overlapBottom * ratio2;
                            }
                            
                            // Keep images within canvas bounds
                            keepImageInBounds(img1);
                            keepImageInBounds(img2);
                        }
                    }
                }
            }
            
            // If we've hit max iterations but still have collisions, try reducing image sizes
            if (!collisionsResolved) {
                // Apply a small scale reduction to all images
                // This ensures a solution when space is very limited
                imageArray.forEach(img => {
                    img.scaleFactor *= 0.95; // Reduce by 5%
                    keepImageInBounds(img);
                });
            }
            
            // Update collision status display
            updateCollisionStatus(!collisionsResolved);
        }
        
        // Function to toggle collision detection
        function toggleCollision() {
            isCollisionEnabled = !isCollisionEnabled;
            updateCollisionStatus();
            
            // If toggling on, immediately apply collision resolution
            if (isCollisionEnabled && (images.length > 1)) {
                resolveCollisions(images);
                updateUI();
            }
            
            saveState();
        }
        
        // Function to update the collision status display
        function updateCollisionStatus(hasCollisions = false) {
            const collisionStatus = document.getElementById('collision-status');
            if (!collisionStatus) return;
            
            if (isCollisionEnabled) {
                collisionStatus.textContent = hasCollisions ? "Collision: DETECTED" : "Collision: ON";
                collisionStatus.className = hasCollisions ? "active warning" : "active";
            } else {
                collisionStatus.textContent = "Collision: OFF";
                collisionStatus.className = "";
            }
        }
        
        // Helper function to keep an image within canvas bounds
        function keepImageInBounds(img) {
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            const imgWidth = img.width * img.scaleFactor;
            const imgHeight = img.height * img.scaleFactor;
            
            // Ensure at least 25% of the image is visible on each edge
            const minVisiblePart = 0.25;
            
            // Constrain x position
            img.x = Math.max(-(imgWidth * (1 - minVisiblePart)), 
                             Math.min(img.x, canvasWidth - (imgWidth * minVisiblePart)));
            
            // Constrain y position
            img.y = Math.max(-(imgHeight * (1 - minVisiblePart)), 
                             Math.min(img.y, canvasHeight - (imgHeight * minVisiblePart)));
        }
    }
    
    // Helper function to shuffle an array
    function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
    
    function handleTouchStart(e) {
        // Prevent default to avoid scrolling when interacting with canvas elements
        e.preventDefault();
        
        if (e.touches.length === 1) {
            // Single touch - handle as drag/select
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handleMouseDown(mouseEvent);
        } 
        else if (e.touches.length === 2 && selectedImageIndex !== -1) {
            // Two finger touch - prepare for pinch zoom on selected image
            isDragging = false;
            isResizing = true;
            resizeDirection = 'se'; // Default to bottom-right resize for pinch
            
            // Store initial distance between the two touches
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialTouchDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            // Store the initial scale of the selected image
            const img = images[selectedImageIndex];
            initialScale = img.scaleFactor;
            
            // Store initial width, height, and position
            initialWidth = img.width * img.scaleFactor;
            initialHeight = img.height * img.scaleFactor;
            initialX = img.x;
            initialY = img.y;
        }
    }
    
    function handleTouchMove(e) {
        // Prevent default scrolling behavior
        e.preventDefault();
        
        if (e.touches.length === 1 && (isDragging || isResizing)) {
            // Single touch - handle as drag or single-finger resize
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handleMouseMove(mouseEvent);
        } 
        else if (e.touches.length === 2 && isResizing && selectedImageIndex !== -1) {
            // Handle pinch zoom for image resizing
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            // Calculate current distance between touches
            const currentDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            // Calculate scale factor change based on pinch gesture
            const scaleFactor = currentDistance / initialTouchDistance;
            
            // Apply the scaling to the selected image
            const img = images[selectedImageIndex];
            const aspectRatio = img.width / img.height;
            
            // Calculate new dimensions
            let newWidth = Math.max(50, initialWidth * scaleFactor);
            let newHeight = newWidth / aspectRatio;
            
            // Keep image centered during pinch zoom
            const newX = initialX - (newWidth - initialWidth) / 2;
            const newY = initialY - (newHeight - initialHeight) / 2;
            
            // Apply changes
            img.scaleFactor = newWidth / img.width;
            img.x = newX;
            img.y = newY;
            
            // Update the scale slider
            const scalePercent = Math.round(img.scaleFactor * 100);
            imageScale.value = scalePercent;
            imageScaleValue.textContent = `${scalePercent}%`;
            
            updateUI();
        }
    }
    
    function handleTouchEnd(e) {
        if (isDragging || isResizing) {
            isDragging = false;
            isResizing = false;
            initialTouchDistance = 0;
            saveState();
            updateUI();
        }
    }

    // Define keyboard shortcuts
    const SHORTCUTS = {
        TOGGLE_THEME: { key: 'i', ctrl: true, description: 'Toggle dark/light theme' },
        EXPORT_PNG: { key: 'e', description: 'Export as PNG' },
        UNDO: { key: 'z', ctrl: true, description: 'Undo last action' },
        REDO: { key: 'y', ctrl: true, description: 'Redo last action' },
        DELETE: { key: 'Delete', description: 'Delete selected element' },
        BRING_FRONT: { key: 'ArrowUp', ctrl: true, description: 'Bring to front' },
        SEND_BACK: { key: 'ArrowDown', ctrl: true, description: 'Send to back' },
        RESET_CANVAS: { key: 'r', ctrl: true, description: 'Reset canvas' },
        TOGGLE_COLLISION: { key: 'c', description: 'Toggle collision detection' },
        ADD_TEXT: { key: 'a', description: 'Add new text' },
        ASPECT_1_1: { key: '1', ctrl: true, description: 'Set 1:1 aspect ratio' },
        ASPECT_4_3: { key: '2', ctrl: true, description: 'Set 4:3 aspect ratio' },
        ASPECT_16_9: { key: '3', ctrl: true, description: 'Set 16:9 aspect ratio' },
        ASPECT_9_16: { key: '4', ctrl: true, description: 'Set 9:16 aspect ratio' }
    };

    // Handle keyboard shortcuts
    function handleKeyboardShortcuts(e) {
        // Don't trigger shortcuts when typing in input fields
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }
        
        // Check for keyboard shortcuts
        const ctrlPressed = e.ctrlKey || e.metaKey; // Support for both Windows/Linux and Mac
        
        // Toggle theme with Cmd+I / Ctrl+I
        if (ctrlPressed && e.key.toLowerCase() === SHORTCUTS.TOGGLE_THEME.key) {
            e.preventDefault();
            toggleDarkMode();
        }
        
        // Export as PNG with 'E' key
        else if (e.key.toLowerCase() === SHORTCUTS.EXPORT_PNG.key) {
            e.preventDefault();
            exportAsPNG();
        }
        
        // Undo with Ctrl+Z / Cmd+Z
        else if (ctrlPressed && e.key.toLowerCase() === SHORTCUTS.UNDO.key) {
            e.preventDefault();
            handleUndo();
        }
        
        // Redo with Ctrl+Y / Cmd+Y
        else if (ctrlPressed && e.key.toLowerCase() === SHORTCUTS.REDO.key) {
            e.preventDefault();
            handleRedo();
        }
        
        // Delete selected element with Delete key
        else if (e.key === SHORTCUTS.DELETE.key) {
            if (selectedText) {
                e.preventDefault();
                deleteSelectedText();
            } else if (selectedImage) {
                e.preventDefault();
                deleteSelectedImage();
            }
        }
        
        // Bring to front with Ctrl+Up / Cmd+Up
        else if (ctrlPressed && e.key === SHORTCUTS.BRING_FRONT.key && selectedImage) {
            e.preventDefault();
            bringSelectedImageToFront();
        }
        
        // Send to back with Ctrl+Down / Cmd+Down
        else if (ctrlPressed && e.key === SHORTCUTS.SEND_BACK.key && selectedImage) {
            e.preventDefault();
            sendSelectedImageToBack();
        }
        
        // Reset canvas with Ctrl+R / Cmd+R
        else if (ctrlPressed && e.key.toLowerCase() === SHORTCUTS.RESET_CANVAS.key) {
            e.preventDefault();
            resetCanvas();
        }
        
        // Toggle collision detection with 'C' key
        else if (e.key.toLowerCase() === SHORTCUTS.TOGGLE_COLLISION.key) {
            e.preventDefault();
            toggleCollision();
        }
        
        // Add new text with 'A' key
        else if (e.key.toLowerCase() === SHORTCUTS.ADD_TEXT.key) {
            e.preventDefault();
            addNewText();
        }
        
        // Set aspect ratio with Cmd+1 / Ctrl+1 (1:1 square)
        else if (ctrlPressed && e.key === SHORTCUTS.ASPECT_1_1.key) {
            e.preventDefault();
            updateCanvasAspectRatio(1); // 1:1 ratio
            
            // Update aspect ratio selector if it exists
            const aspectRatio = document.getElementById('aspect-ratio');
            if (aspectRatio) aspectRatio.value = '1';
        }
        
        // Set aspect ratio with Cmd+2 / Ctrl+2 (4:3)
        else if (ctrlPressed && e.key === SHORTCUTS.ASPECT_4_3.key) {
            e.preventDefault();
            updateCanvasAspectRatio(4/3); // 4:3 ratio
            
            // Update aspect ratio selector if it exists
            const aspectRatio = document.getElementById('aspect-ratio');
            if (aspectRatio) aspectRatio.value = '1.33';
        }
        
        // Set aspect ratio with Cmd+3 / Ctrl+3 (16:9)
        else if (ctrlPressed && e.key === SHORTCUTS.ASPECT_16_9.key) {
            e.preventDefault();
            updateCanvasAspectRatio(16/9); // 16:9 ratio
            
            // Update aspect ratio selector if it exists
            const aspectRatio = document.getElementById('aspect-ratio');
            if (aspectRatio) aspectRatio.value = '1.78';
        }
        
        // Set aspect ratio with Cmd+4 / Ctrl+4 (9:16 - vertical video)
        else if (ctrlPressed && e.key === SHORTCUTS.ASPECT_9_16.key) {
            e.preventDefault();
            updateCanvasAspectRatio(9/16); // 9:16 ratio
            
            // Update aspect ratio selector if it exists
            const aspectRatio = document.getElementById('aspect-ratio');
            if (aspectRatio) aspectRatio.value = '0.56';
        }
    }

    // Add keyboard shortcut event listener
    window.addEventListener('keydown', handleKeyboardShortcuts);

    // Function to display available shortcuts in a tooltip or modal
    function showShortcutsHelp() {
        const helpContent = document.createElement('div');
        helpContent.className = 'shortcuts-help';
        helpContent.innerHTML = `
            <h2>Keyboard Shortcuts</h2>
            <ul>
                ${Object.values(SHORTCUTS).map(shortcut => {
                    let keyDisplay = shortcut.key;
                    if (shortcut.key === 'Delete') keyDisplay = 'Del';
                    if (shortcut.key === 'ArrowUp') keyDisplay = '';
                    if (shortcut.key === 'ArrowDown') keyDisplay = '';
                    
                    const modifierKey = shortcut.ctrl ? (navigator.platform.indexOf('Mac') > -1 ? '' : 'Ctrl+') : '';
                    return `<li><kbd>${modifierKey}${keyDisplay.toUpperCase()}</kbd> - ${shortcut.description}</li>`;
                }).join('')}
            </ul>
        `;
        
        // Show the help content in a modal
        const modal = document.createElement('div');
        modal.className = 'modal shortcuts-modal';
        modal.innerHTML = `
            <div class="modal-content">
                ${helpContent.outerHTML}
                <button id="close-shortcuts-help" class="close-btn">Close</button>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Close modal when clicking the close button
        document.getElementById('close-shortcuts-help').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }

    // Add a "?" button to show keyboard shortcuts
    document.addEventListener('DOMContentLoaded', () => {
        const toolbar = document.querySelector('.toolbar');
        if (toolbar) {
            const shortcutsBtn = document.createElement('button');
            shortcutsBtn.innerHTML = '<i class="fas fa-keyboard"></i> Shortcuts';
            shortcutsBtn.title = 'Show keyboard shortcuts';
            shortcutsBtn.addEventListener('click', showShortcutsHelp);
            
            // Add to the first toolbar group or create one
            let toolbarGroup = toolbar.querySelector('.toolbar-group');
            if (!toolbarGroup) {
                toolbarGroup = document.createElement('div');
                toolbarGroup.className = 'toolbar-group';
                toolbar.appendChild(toolbarGroup);
            }
            
            toolbarGroup.appendChild(shortcutsBtn);
        }
    });

    // Import keyboard shortcuts module
    const keyboardScript = document.createElement('script');
    keyboardScript.src = 'keyboard-shortcuts.js';
    document.head.appendChild(keyboardScript);
});
